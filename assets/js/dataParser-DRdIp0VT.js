import{s as y,l as F}from"./universalFooter-Cs4O4ZF4.js";const p="/apap_template/";function w(t){const r=t.startsWith("/")?t.slice(1):t;return(p.endsWith("/")?p:p+"/")+r}const C={config:{datasetConfig:{multivalue_rows:{},fields:{}}},async init(){try{const t=await F();return t?(this.config=t,this.config.datasetConfig?(this.config.datasetConfig.multivalue_rows||(this.config.datasetConfig.multivalue_rows={}),this.config.datasetConfig.fields||(this.config.datasetConfig.fields={})):this.config.datasetConfig={multivalue_rows:{},fields:{}}):console.warn("loadConfiguration returned undefined or null, using default config"),this}catch(t){return console.error("Error loading configuration:",t),console.warn("Using default configuration due to error"),this}},async saveConfig(){try{return await y(this.config),console.log("Configuration saved successfully with updated fields"),!0}catch(t){return console.error("Error saving configuration:",t),!1}},async parseData(){try{const[t,r]=await Promise.all([fetch(w("data/references.tsv")),fetch(w("data/locations.tsv"))]),[c,f]=await Promise.all([t.text(),r.text()]),i=this.parseTsvToJson(c),e=this.parseTsvToJson(f),s=i.length>0?Object.keys(i[0]):[],l=e.length>0?Object.keys(e[0]):[],n={catalogue:s,geodata:l,all:[...new Set([...s,...l])]},o=this.config.datasetConfig.fields;JSON.stringify(o)!==JSON.stringify(n)?(this.config.datasetConfig.fields=n,console.log("Dataset fields updated:",this.config.datasetConfig.fields),await this.saveConfig()?console.log("Fields permanently saved to config file"):console.warn("Failed to save fields to config file")):console.log("Fields unchanged, no need to update config file");let g=null;if(s.includes("Location")&&l.includes("Location")?g="Location":s.includes("Titolo")&&l.includes("Titolo")&&(g="Titolo"),!g)return console.warn("No common join field found. Available fields:"),console.warn("Catalogue fields:",s),console.warn("Geodata fields:",l),this.processMultivalueFields([...i,...e]);console.log(`Using "${g}" as join field`);const a=[];return e.forEach(u=>{const v=i.filter(h=>h[g]===u[g]);v.length>0?v.forEach(h=>{const m={...h,...u};a.push(m)}):a.push(u)}),this.processMultivalueFields(a)}catch(t){return console.error("Error in parseData:",t),[]}},processMultivalueFields(t){var c,f;const r=((f=(c=this.config)==null?void 0:c.datasetConfig)==null?void 0:f.multivalue_rows)||{};return t.forEach(i=>{Object.keys(r).forEach(e=>{if(i[e]&&typeof i[e]=="string"){const s=r[e];i[e]=i[e].split(s).map(l=>l.trim())}})}),t},parseTsvToJson(t){var e;const r=t.trim().split(/\r?\n/),c=r[0].split("	").map(s=>s.trim()),f=((e=this.config)==null?void 0:e.aggregations)||{},i=Object.keys(f).filter(s=>f[s].type!=="range");return r.slice(1).map(s=>{const l=s.split("	"),n={};return c.forEach((o,d)=>{const a=(d<l.length?l[d]:"").replace(/\r/g,"").trim();if(a===""){i.includes(o)?n[o]="Non specificato":n[o]="";return}a.toLowerCase()==="true"?n[o]=!0:a.toLowerCase()==="false"?n[o]=!1:!isNaN(a)&&a.trim()!==""?o==="Location"||o==="Titolo"?n[o]=a:n[o]=Number(a):n[o]=a}),n})}},D=async()=>(await C.init(),C.parseData());export{D as p};
